require('dotenv').config();
const express = require('express');
const path = require('path');
const fs = require('fs');
const webpush = require('web-push');

const app = express();

app.use(express.json());

// Trust proxy (crucial for AWS/Nginx/Load Balancers to get correct IP/Protocol)
app.enable('trust proxy');

// ---------------------------------------------------------
// NOTIFICATION SYSTEM SETUP
// ---------------------------------------------------------

const VAPID_FILE = 'vapid.json';
const DB_FILE = 'subscriptions.json';
let vapidKeys = {};

// Load or Generate VAPID Keys
if (fs.existsSync(VAPID_FILE)) {
  vapidKeys = JSON.parse(fs.readFileSync(VAPID_FILE, 'utf8'));
} else {
  // Should have been generated by generate-keys.js, but fallback just in case
  vapidKeys = webpush.generateVAPIDKeys();
  fs.writeFileSync(VAPID_FILE, JSON.stringify(vapidKeys, null, 2));
}

// Configure Web Push
webpush.setVapidDetails(
  'mailto:user@workflow-app.com', // Replace with real email if deployed
  vapidKeys.publicKey,
  vapidKeys.privateKey
);

// Comedic Notification Messages (Moved from Service Worker)
const NOTIFICATION_MESSAGES = {
  dueSoon: [
    "â° Hey procrastinator! '{title}' is due in {days} days. Time to panic? ðŸ™ƒ",
    "ðŸš¨ Assignment alert! '{title}' is coming up in {days} days. Netflix can wait!",
    "âš¡ Friendly reminder: '{title}' due in {days} days. Your future self will thank you!",
    "ðŸŽ¯ '{title}' needs attention in {days} days. Let's not make it a last-minute miracle!",
    "ðŸ“š Psst... '{title}' is due in {days} days. Coffee up and let's do this!"
  ],
  late: [
    "ðŸ˜± Uh oh! '{title}' is now OVERDUE. Time to channel your inner superhero! ðŸ¦¸",
    "ðŸ”¥ DEFCON 1: '{title}' is late! But hey, better late than never, right?",
    "âš ï¸ Houston, we have a problem. '{title}' crossed the deadline. Damage control time!",
    "ðŸ’€ '{title}' has entered the danger zone. Quick, before your teacher notices!",
    "ðŸš€ Emergency! '{title}' is overdue. Activate turbo mode NOW!"
  ]
};

// In-Memory Storage for Subscriptions (backed by file)
let userSubscriptions = [];

if (fs.existsSync(DB_FILE)) {
  try {
    userSubscriptions = JSON.parse(fs.readFileSync(DB_FILE, 'utf8'));
  } catch (err) {
    console.error('Error reading subscriptions DB:', err);
    userSubscriptions = [];
  }
}

function saveDb() {
  fs.writeFileSync(DB_FILE, JSON.stringify(userSubscriptions, null, 2));
}

// ---------------------------------------------------------
// API ENDPOINTS
// ---------------------------------------------------------

// Security Middleware: Prevent access to backend files
app.use((req, res, next) => {
  const forbiddenFiles = [
    '/server.js',
    '/package.json',
    '/package-lock.json',
    '/.env',
    '/.git',
    '/vapid.json',
    '/subscriptions.json'
  ];
  if (forbiddenFiles.some(file => req.url.startsWith(file))) {
    return res.status(403).send('Forbidden');
  }
  next();
});

// Set proper MIME types
app.use((req, res, next) => {
  if (req.url.endsWith('.js')) {
    res.type('application/javascript');
  } else if (req.url.endsWith('.json')) {
    res.type('application/json');
  }
  next();
});

// 1. Get Public Key
app.get('/api/vapid-public-key', (req, res) => {
  res.json({ publicKey: vapidKeys.publicKey });
});

// 2. Subscribe and Update Assignments
app.post('/api/subscribe', (req, res) => {
  const { subscription, assignments } = req.body;

  if (!subscription || !subscription.endpoint) {
    return res.status(400).json({ error: 'Invalid subscription' });
  }

  // Check if subscription already exists
  const existingUserIndex = userSubscriptions.findIndex(
    user => user.subscription.endpoint === subscription.endpoint
  );

  const newEntry = {
    subscription,
    assignments: assignments || [],
    lastNotified: existingUserIndex !== -1 ? userSubscriptions[existingUserIndex].lastNotified : {}
  };

  if (existingUserIndex !== -1) {
    userSubscriptions[existingUserIndex] = newEntry;
  } else {
    userSubscriptions.push(newEntry);
  }

  saveDb();
  res.status(201).json({ message: 'Subscription saved' });
});

// 3. Trigger Notification Loop (Can be called externally or runs on interval)
// We run this internal loop
setInterval(checkAndSendNotifications, 60 * 1000); // Check every minute (for demo purposes)

async function checkAndSendNotifications() {
  const now = new Date();

  // Iterate through all users
  for (let i = 0; i < userSubscriptions.length; i++) {
    const user = userSubscriptions[i];
    let updated = false;

    // Iterate through assignments
    for (const assignment of user.assignments) {
      if (!assignment.dueDate) continue;

      const dueDate = new Date(
        assignment.dueDate.year,
        assignment.dueDate.month - 1,
        assignment.dueDate.day
      );

      const diffTime = dueDate - now;
      const daysUntilDue = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      let type = null;
      let days = Math.abs(daysUntilDue);

      if (daysUntilDue < 0 && assignment.status === 'late') {
        type = 'late';
      } else if (daysUntilDue >= 1 && daysUntilDue <= 3 && assignment.status === 'pending') {
        type = 'dueSoon';
      }

      if (type) {
        // Check debounce (prevent spamming same notification within 24h)
        const key = `${assignment.title}_${type}`;
        const lastSent = user.lastNotified[key] || 0;

        if (Date.now() - lastSent > 24 * 60 * 60 * 1000) {
           // Send Notification
           await sendPushNotification(user.subscription, assignment, type, days)
             .then(() => {
               user.lastNotified[key] = Date.now();
               updated = true;
             })
             .catch(err => {
               if (err.statusCode === 410 || err.statusCode === 404) {
                 // Subscription expired/invalid
                 console.log('Subscription expired, removing user.');
                 userSubscriptions.splice(i, 1);
                 i--; // adjust index
                 updated = true;
               } else {
                 console.error('Error sending push:', err);
               }
             });
        }
      }
    }

    if (updated) saveDb();
  }
}

async function sendPushNotification(subscription, assignment, type, days) {
  const messages = NOTIFICATION_MESSAGES[type];
  const messageText = messages[Math.floor(Math.random() * messages.length)]
    .replace('{title}', assignment.title)
    .replace('{days}', days);

  const payload = JSON.stringify({
    title: 'WorkFlow Assignment Alert',
    body: messageText,
    icon: '/icons/icon-192x192.png',
    data: {
      url: assignment.link || '/',
      assignmentId: assignment.title
    }
  });

  return webpush.sendNotification(subscription, payload);
}

// ---------------------------------------------------------
// STANDARD ROUTES
// ---------------------------------------------------------

// Serve service worker explicitly from root (required for PWA scope)
app.get('/service-worker.js', (req, res) => {
  res.sendFile(path.join(__dirname, 'service-worker.js'));
});

// Serve manifest explicitly
app.get('/manifest.json', (req, res) => {
  res.sendFile(path.join(__dirname, 'manifest.json'));
});

// Serve offline page explicitly
app.get('/offline.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'offline.html'));
});

// Serve 'node_modules' as static files (Note: only if needed by frontend)
// Kept for compatibility with your setup, but recommend removing if not used.
app.use('/node_modules', express.static(path.join(__dirname, 'node_modules')));

// Serve static files (HTML, CSS, JS, icons)
app.use(express.static(path.join(__dirname, '/')));

// Proxy endpoint for OpenAI Chat
app.post('/api/chat', async (req, res) => {
  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${process.env.OPENAI_KEY}`
      },
      body: JSON.stringify(req.body)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenAI API Error:', response.status, errorText);
      return res.status(response.status).send(errorText);
    }

    const data = await response.json();
    res.json(data);
  } catch (error) {
    console.error('Proxy Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Fallback to index.html for SPA routing (Client-side routing)
app.get('', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

// Start the server
const PORT = process.env.PORT || 8080;
// Bind to 0.0.0.0 to allow external access (AWS requirement)
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
  console.log(`ðŸ“± PWA ready for installation`);
  console.log(`ðŸ”‘ VAPID Public Key: ${vapidKeys.publicKey}`);
  console.log(`\nâœ… Features enabled:`);
  console.log(`  - Offline support`);
  console.log(`  - Auto-updates`);
  console.log(`  - Push Notifications (Background)`);
});
